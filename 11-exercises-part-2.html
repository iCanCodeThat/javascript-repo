<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>11 Exercises Part 2</title>
  </head>
  <body>
    <script>
      /****************** Exercises 11 0, p, q *****************/

      //  Exercise O
      //  array of strings and loop over the array, and check if the
      //  the string 'search' is inside the array. console.log the 
      //  index of 'search', if there is no 'search' console.log 
      //  '-1';
      let words = ['hello', 'world', 'search', 'good', 'search'];

      // Set the index to -1 at the start (so we'll assume
      // the string 'search' doesn't exist in the array).
      // If we find the string 'search' in the array, we
      // will update the index.
      let index = -1;

      for (let i = 0; i < words.length; i++) {
       
        if (words[i] === 'search') {
          index = i;
        }
      }

      console.log(index);

      //  Exercise P (Modified Exercise O)
      //  if 'not' appears multiple times in the array, it will console.log
      //  the index of the first appearance using break;
        words = ['not', 'found', 'not', 'now'];
        index = -1;

        for (let i = 0; i < words.length; i++) {
          if (words[i] === 'not') {
            index = i;
            break;
          }
        }

        console.log(index);


        //  Exercise Q
        //  function that searches an array for a string in a word parameter
        //  and returns the index of the first appearance of the string
        //  if it dont exist in the array, return -1

        function findIndex(array, word) {
          for (let i = 0; i < array.length; i++) {
            if (array[i] === word) {
              // Instead of creating an accumulator
              // variable and updating it in the loop,
              // we can just return i directly, when
              // we find it since this is a function.
              return i;
            }
          }
  
          // If the function has not returned by now,
          // logically that means the word must not
          // exist in the array, so we'll return -1.
          return -1;
        }
        console.log(findIndex(['green', 'red', 'blue'], 'red'));

        // Exercise R
        //  function that takes an array of string and returns an array
        //  where the string 'egg' is removed.

        function removeEgg1(foods){
        const result = [];

          for(let i = 0; i < foods.length; i++){
            
            if(foods[i] === 'egg'){
              continue;
              
            }
            result.push(foods[i]);
          }

          return result;


        }
        console.log(removeEgg1(['egg', 'apple','egg','grapes']));
        
        //  Exervise S (Updated Exercise R)
        //  only removes the first 2 eggs from the array;
        function removeEgg2(foods) {
          const result = [];
          let eggsRemoved = 0;
  
          for (let i = 0; i < foods.length; i++) {
            // Only skip 'egg' if we removed less than 2
            // of them so far.
            if (foods[i] === 'egg' && eggsRemoved < 2) {
              // Update the number of 'egg' we have removed.
              // This must be done before continue, otherwise,
              // doing continue first will just skip this code.
              eggsRemoved++;
              continue;
            }
  
            result.push(foods[i]);
          }
  
          return result;
        }
  
        console.log(removeEgg2(['egg', 'apple', 'egg', 'egg', 'ham']));

        //  Exercise T (Updated Exercise S)
        // using reverse(), only remove the last 2 from the array
        function removeEgg3(foods) {
          // To remove the last 2 'egg', reverse the array first.
          const reversedFoods = foods.reverse();
  
          const result = [];
          let eggsRemoved = 0;
  
          for (let i = 0; i < reversedFoods.length; i++) {
            if (foods[i] === 'egg' && eggsRemoved < 2) {
              eggsRemoved++;
              continue;
            }
  
            result.push(foods[i]);
          }
  
          // At the end, remember to .reverse() back the result.
          return result.reverse();
        }
  
        console.log(removeEgg3(['egg', 'apple', 'egg', 'egg', 'ham']));
        
        //  Exercise U  (Updated Exercise T)
        //  update the code so the function does not modify the original array using slice()
        function removeEgg(foods4) {
          // To prevent modifying the original array, we
          // just need to create a copy using .slice()
          const foodsCopy = foods4.slice();
          const reversedFoods = foodsCopy.reverse();
  
          // We can also write the code in 1 line since
          // .slice() results in an array, which means
          // we can use .reverse() on the result directly.
          // This is called "method chaining".
          /*
          const reversedFoods = foods.slice().reverse();
          */
  
          const result = [];
          let eggsRemoved = 0;
  
          for (let i = 0; i < reversedFoods.length; i++) {
            if (foods4[i] === 'egg' && eggsRemoved < 2) {
              eggsRemoved++;
              continue;
            }
  
            result.push(foods4[i]);
          }
  
          return result.reverse();
        }
  
        const foods4 = ['egg', 'apple', 'egg', 'egg', 'ham'];
        console.log(removeEgg(foods4));
        console.log(foods4);


        //  Exercise V FizzBuzz
        //  loop that displays 1-30, if it is divisible by 3, display
        //  'Fizz'
        //  if its divisible by 5
        //  'Buzz'
        //  if its divisible by 3 and 5
        //  'FizzBuzz'
        for(let i = 1; i<=30; i++){
          if(i % 3 === 0 && i %5===0){
            console.log('FuzzBuzz');
            continue;
          } else if(i % 3 === 0 ){
            console.log('Fizz');
            continue;
          } else if(i % 5 === 0){
            console.log('Buzz');
            continue;
          }
          console.log(i);
        }
        
        //  Exercise W
        //  function unique that takes an array of string and returns an array where each string only appears once

        function findIndex2(array, word) {
          const result = [];
          for (let i = 0; i < array.length; i++) {
            if (array[i] === word) {
              return i;
            }
            
          }
          return -1;
  
          
        }
        console.log(findIndex2(['green', 'apple', 'apple'],'green'));
       

        function unique(array) {
          const result = [];
  
          for (let i = 0; i < array.length; i++) {
            const word = array[i];
  
            // Using the findIndex() function from above, we
            // can check if the string is already in the
            // result array. If it's not in the result array
            // (index is -1), then add it to the result array.
            if (findIndex2(result, word)=== -1) {
              result.push(word);
            }
          }
  
          return result;
        }
  
        console.log(unique(['green', 'red', 'blue', 'red','orange','orange']));
        console.log(unique(['red', 'green', 'green', 'red']));
      
    </script>
  </body>
</html>
